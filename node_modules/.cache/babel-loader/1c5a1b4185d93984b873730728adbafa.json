{"ast":null,"code":"'use strict';\n\nclass AbortError extends Error {\n  constructor() {\n    super('Throttled function aborted');\n    this.name = 'AbortError';\n  }\n\n}\n\nconst pThrottle = _ref => {\n  let {\n    limit,\n    interval,\n    strict\n  } = _ref;\n\n  if (!Number.isFinite(limit)) {\n    throw new TypeError('Expected `limit` to be a finite number');\n  }\n\n  if (!Number.isFinite(interval)) {\n    throw new TypeError('Expected `interval` to be a finite number');\n  }\n\n  const queue = new Map();\n  let currentTick = 0;\n  let activeCount = 0;\n\n  function windowedDelay() {\n    const now = Date.now();\n\n    if (now - currentTick > interval) {\n      activeCount = 1;\n      currentTick = now;\n      return 0;\n    }\n\n    if (activeCount < limit) {\n      activeCount++;\n    } else {\n      currentTick += interval;\n      activeCount = 1;\n    }\n\n    return currentTick - now;\n  }\n\n  const strictTicks = [];\n\n  function strictDelay() {\n    const now = Date.now();\n\n    if (strictTicks.length < limit) {\n      strictTicks.push(now);\n      return 0;\n    }\n\n    const earliestTime = strictTicks.shift() + interval;\n\n    if (now >= earliestTime) {\n      strictTicks.push(now);\n      return 0;\n    }\n\n    strictTicks.push(earliestTime);\n    return earliestTime - now;\n  }\n\n  const getDelay = strict ? strictDelay : windowedDelay;\n  return function_ => {\n    const throttled = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (!throttled.isEnabled) {\n        return (async () => function_.apply(this, args))();\n      }\n\n      let timeout;\n      return new Promise((resolve, reject) => {\n        const execute = () => {\n          resolve(function_.apply(this, args));\n          queue.delete(timeout);\n        };\n\n        timeout = setTimeout(execute, getDelay());\n        queue.set(timeout, reject);\n      });\n    };\n\n    throttled.abort = () => {\n      for (const timeout of queue.keys()) {\n        clearTimeout(timeout);\n        queue.get(timeout)(new AbortError());\n      }\n\n      queue.clear();\n      strictTicks.splice(0, strictTicks.length);\n    };\n\n    throttled.isEnabled = true;\n    return throttled;\n  };\n};\n\nmodule.exports = pThrottle;\nmodule.exports.AbortError = AbortError;","map":null,"metadata":{},"sourceType":"script"}